from flask import Blueprint
from tracemalloc import start
import cv2
import matplotlib.pyplot as plt
import cvlib as cv
import urllib.request
import numpy as np
import sys
from cvlib.object_detection import draw_bbox
import concurrent.futures
import math
import asyncio
import time 
import statistics


 
#url='http://10.0.0.104/capture?_cb=1646718454115' Change the URL below to the URL generated by 
#the arduino software.
#rightclick the image and open in a new tab for a still image. Doesn't work with just the IP address
#Let me know (Angus) if you have any issues
url='http://10.0.0.102/capture?_cb=1649020515981'
im=None

water = Blueprint('water',__name__)

@water.route("/water")

def waterLevel(imgcopy, bbox,status):
    x1 = bbox[0]
    y1 = bbox[1]
    w1 = bbox[2]
    h1 = bbox[3]
    crop_img = imgcopy[y1:h1, x1:w1]
    height, width = crop_img.shape[:2]
    statuswater = status
    if not crop_img.all():
        gray = cv2.cvtColor(crop_img, cv2.COLOR_RGBA2GRAY)
        cv2.imshow("gray", gray)
        blurred = cv2.GaussianBlur(gray,(5,5),0)
        th3 = cv2.adaptiveThreshold(blurred,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY_INV, 21,5)
        #cv2.imshow("th3", th3)
        edges = cv2.Canny(th3, 100, 250, apertureSize = 7)
        #cv2.imshow("edges",edges)
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(9,9))
        dilated = cv2.dilate(edges, kernel)

        contours, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        contoursimage = crop_img.copy()
        cv2.drawContours(contoursimage, contours, -1, (0, 255, 0), 2)
        #cv2.imshow("Contours", contoursimage)
        areaArray = []
        for c in enumerate(contours):
            area = cv2.contourArea(c)
            areaArray.append(area)
        print(areaArray)
        avg_area = statistics.mean(areaArray)

        for c in areaArray:
            if len(areaArray) > 3:
                areaArray.remove(min(areaArray))
            if c < (avg_area/3) and c in areaArray:
                print(c)
                areaArray.remove(c)
        if len(areaArray) > 2:
            
            sorteddata = sorted(zip(areaArray, contours), key=lambda x: x[0], reverse=True)
            print(sorteddata)
            waterLevel = sorteddata[0][1]
            x,y,w,h = cv2.boundingRect(waterLevel)

            waterLevel2 = sorteddata[1][1]
            x2,y2,w2,h2 = cv2.boundingRect(waterLevel2)
            waterLevel3 = sorteddata[2][1]
            x3,y3,w3,h3 = cv2.boundingRect(waterLevel3)

            horizontalMidPoint = round((y+y+h)*0.5)
            horizontalMidPoint2 = round((y2+y2+h2)*0.5)
            horizontalMidPoint3 = round((y3+y3+h3)*0.5)
            midPointArray = [horizontalMidPoint, horizontalMidPoint2, horizontalMidPoint3]

            midPointArray.sort()
            print(midPointArray)

            horizontalMidPoint = midPointArray[1]
            aspectRatio = (height - horizontalMidPoint)/ float(height)
            print(aspectRatio)
            if aspectRatio > 0.4:
                cv2.line(crop_img, (x,horizontalMidPoint),(w,horizontalMidPoint),(255,0,0),2)
                cv2.putText(imgcopy, "Full", (x1, horizontalMidPoint), cv2.FONT_HERSHEY_PLAIN, 1, (0, 0, 255), 2)
                statuswater = "Full"
            else:
                cv2.line(crop_img, (x,horizontalMidPoint),(w,horizontalMidPoint),(255,0,0),2)
                cv2.putText(imgcopy, "Low", (x1, horizontalMidPoint), cv2.FONT_HERSHEY_PLAIN, 1, (0, 0, 255), 2)
                statuswater = "Low"
        elif len(areaArray) == 2:
            sorteddata = sorted(zip(areaArray, contours), key=lambda x: x[0], reverse=True)
            waterLevel = sorteddata[0][1]
            x,y,w,h = cv2.boundingRect(waterLevel)
            # print(y)
            # print(h)
            horizontalMidPoint = round((y+y+h)*0.5)
            aspectRatio = (height - horizontalMidPoint)/ float(height)
            print(aspectRatio)
            if aspectRatio > 0.4:
                cv2.line(crop_img, (x,horizontalMidPoint),(w,horizontalMidPoint),(255,0,0),2)
                cv2.putText(imgcopy, "Full", (x1, horizontalMidPoint), cv2.FONT_HERSHEY_PLAIN, 1, (0, 0, 255), 2)
                statuswater = "Full"
            else:
                cv2.line(crop_img, (x,horizontalMidPoint),(w,horizontalMidPoint),(255,0,0),2)
                cv2.putText(imgcopy, "Low", (x1, horizontalMidPoint), cv2.FONT_HERSHEY_PLAIN, 1, (0, 0, 255), 2)
                statuswater = "Low"
    return (statuswater)
    #await asyncio.sleep(1)
    

def run1(img):

    bbox, label, conf = cv.detect_common_objects(img)
    print(bbox)
    img = draw_bbox(img, bbox, label, conf)
    status = "No Cup"
    # cv2.imshow("image", img)
    if "cup" not in label:
        return status
    else: 
        for x in range(len(label)):
            if label[x] == 'cup' or label[x] == 'bottle' or label[x] == 'glass':
                status = waterLevel(img,bbox[x],status)
    return status
                
    #cv2.destroyAllWindows()
 
# if __name__ == '__main__':
#     print("started")
    
#     loop = asyncio.get_event_loop()
#     loop.run_until_complete(run1())