import enum
from ssl import ALERT_DESCRIPTION_ILLEGAL_PARAMETER
from tracemalloc import start
import cv2
from cv2 import medianBlur
import matplotlib.pyplot as plt
import cvlib as cv
import urllib.request
import numpy as np
import sys
from cvlib.object_detection import draw_bbox
import concurrent.futures
import math
import asyncio
import statistics
# from skimage.transform import hough_ellipse


 
#url='http://10.0.0.104/capture?_cb=1646718454115' Change the URL below to the URL generated by 
#the arduino software.
#rightclick the image and open in a new tab for a still image. Doesn't work with just the IP address
#Let me know (Angus) if you have any issues
url='http://10.0.0.102/capture?_cb=1651276167793'
im=None
 

async def waterLevel(imgcopy, bbox):
    x1 = bbox[0]
    y1 = bbox[1]
    w1 = bbox[2]
    h1 = bbox[3]
    crop_img = imgcopy[y1:h1, x1-10:w1+10]
    # cv2.rectangle(imgcopy, (x1,y1), (w1,h1), (255,0,0), 2)
    height, width = crop_img.shape[:2]
    # cv2.imshow("crop_img", crop_img)
    # print(crop_img)
    if not crop_img.all():
        # test = cv2.cvtColor(crop_img, cv2.COLOR_BGR2HSV)
        # cv2.imshow("test", test)
        # gray = cv2.cvtColor(crop_img, cv2.COLOR_BGRA2RGB)
        # cv2.imshow("gray", gray)
        gray = cv2.cvtColor(crop_img, cv2.COLOR_RGBA2GRAY)
        cv2.imshow("gray", gray)
        blurred = cv2.GaussianBlur(gray,(5,5),0)
        # blurred = medianBlur(gray, 51)
        # (T, threshInv) = cv2.threshold(blurred, 100, 255, cv2.THRESH_BINARY_INV)
        # th3 = cv2.adaptiveThreshold(crop_img,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,11,2)
        th3 = cv2.adaptiveThreshold(blurred,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY_INV, 21,5)
        cv2.imshow("th3", th3)
        
        # This one works
        # edges = cv2.Canny(th3, 40, 100, apertureSize = 3)
        # test
        edges = cv2.Canny(th3, 100, 250, apertureSize = 7)
        # edges = cv2.Canny(th3, 40, 180)
        # cv2.imshow("Threshold", threshInv)

        cv2.imshow("edges",edges)
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(9,9))
        dilated = cv2.dilate(edges, kernel)
        # cv2.imshow("Dilated", dilated)

        contours, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        contoursimage = crop_img.copy()
        cv2.drawContours(contoursimage, contours, -1, (0, 255, 0), 2)
        cv2.imshow("Contours", contoursimage)
        areaArray = []
        for i, c in enumerate(contours):
            area = cv2.contourArea(c)
            areaArray.append(area)
        print(areaArray)
        avg_area = statistics.mean(areaArray)

        for c in areaArray:
            if len(areaArray) > 3:
                areaArray.remove(min(areaArray))
            if c < (avg_area/3) and c in areaArray:
                print(c)
                areaArray.remove(c)
        

        print(areaArray)

        if len(areaArray) > 2:
            
            sorteddata = sorted(zip(areaArray, contours), key=lambda x: x[0], reverse=True)
            print(sorteddata)
            waterLevel = sorteddata[0][1]
            x,y,w,h = cv2.boundingRect(waterLevel)

            waterLevel2 = sorteddata[1][1]
            x2,y2,w2,h2 = cv2.boundingRect(waterLevel2)
            waterLevel3 = sorteddata[2][1]
            x3,y3,w3,h3 = cv2.boundingRect(waterLevel3)

            horizontalMidPoint = round((y+y+h)*0.5)
            horizontalMidPoint2 = round((y2+y2+h2)*0.5)
            horizontalMidPoint3 = round((y3+y3+h3)*0.5)
            midPointArray = [horizontalMidPoint, horizontalMidPoint2, horizontalMidPoint3]

            midPointArray.sort()
            print(midPointArray)



            # print(y)
            # print(h)
            # horizontalMidPoint = round((y+y+h)*0.5)

            horizontalMidPoint = midPointArray[1]
            aspectRatio = (height - horizontalMidPoint)/ float(height)
            print(aspectRatio)
            if aspectRatio > 0.4:
                cv2.line(crop_img, (x,horizontalMidPoint),(w,horizontalMidPoint),(255,0,0),2)
                cv2.putText(imgcopy, "Full", (x1, horizontalMidPoint), cv2.FONT_HERSHEY_PLAIN, 1, (0, 0, 255), 2)
                # cv2.rectangle(crop_img,(x,y),(x+w,y+h),(0,0,255),2)
            else:
                cv2.line(crop_img, (x,horizontalMidPoint),(w,horizontalMidPoint),(255,0,0),2)
                cv2.putText(imgcopy, "Low", (x1, horizontalMidPoint), cv2.FONT_HERSHEY_PLAIN, 1, (0, 0, 255), 2)
                # cv2.rectangle(crop_img,(x,y),(x+w,y+h),(0,0,255),2)
        elif len(areaArray) == 2:
            sorteddata = sorted(zip(areaArray, contours), key=lambda x: x[0], reverse=True)
            waterLevel = sorteddata[0][1]
            x,y,w,h = cv2.boundingRect(waterLevel)
            # print(y)
            # print(h)
            horizontalMidPoint = round((y+y+h)*0.5)
            aspectRatio = (height - horizontalMidPoint)/ float(height)
            print(aspectRatio)
            if aspectRatio > 0.4:
                cv2.line(crop_img, (x,horizontalMidPoint),(w,horizontalMidPoint),(255,0,0),2)
                cv2.putText(imgcopy, "Full", (x1, horizontalMidPoint), cv2.FONT_HERSHEY_PLAIN, 1, (0, 0, 255), 2)
                # cv2.rectangle(crop_img,(x,y),(x+w,y+h),(0,0,255),2)
            else:
                cv2.line(crop_img, (x,horizontalMidPoint),(w,horizontalMidPoint),(255,0,0),2)
                cv2.putText(imgcopy, "Low", (x1, horizontalMidPoint), cv2.FONT_HERSHEY_PLAIN, 1, (0, 0, 255), 2)
                # cv2.rectangle(crop_img,(x,y),(x+w,y+h),(0,0,255),2)



        cv2.imshow("Crop", crop_img)

        # contoursimage = crop_img.copy()
        # cv2.drawContours(contoursimage, contours, -1, (0, 255, 0), 2)
        # cv2.imshow("Contours", contoursimage)

        # print(contours)

        # if len(contours) != 0:
        #     for cont in contours:
        #         # if cont.size < 10 or cv2.contourArea(cont) < 100:
        #         #     continue
        #         elps = cv2.fitEllipse(cont)
        #         cv2.ellipse(crop_img,elps, (0,255,0),2)
        #     cv2.imshow("Ellipse",crop_img)


        # (T, threshInv) = cv2.threshold(blurred, 140, 255, cv2.THRESH_BINARY_INV)
        # horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (w1,1))
        # horizontal_mask = cv2.morphologyEx(threshInv, cv2.MORPH_OPEN, horizontal_kernel, iterations=1)
        # edges = cv2.Canny(horizontal_mask,60, 80)
        # cv2.imshow("edges", edges)
        # contours, hierarchy = cv2.findContours(edges,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
        # # cv2.drawContours(imgcopy, contours, -1, (0, 255, 0), 2)
        # if( hierarchy is not None):
        #     number_of_contours = len(hierarchy[0])
        #     if number_of_contours >= 4:
        #         #cv2.drawContours(img, contours, -1, (0, 255, 0), 2)
        #         cropped_height = contours[number_of_contours-4][1][0][1]
        #         contour_height = y1 + contours[number_of_contours-4][1][0][1]
        #         contour_x2 = contours[number_of_contours-4][1][0][0] + x1
        #         contour_x1 = contours[number_of_contours-4][0][0][0] + x1
        #         start_point = (contour_x1,contour_height)
        #         end_point = (contour_x2, contour_height)
        #         imgcopy = cv2.line(imgcopy, start_point, end_point, (0, 255, 0), 2)
        #         aspectRatio = (height - cropped_height)/ float(height)

        #         #print(aspectRatio)

        #         #if water level is below 50%, the cup is low, other wise it doesnt need refill
        #         if aspectRatio > 0.5:
        #             #cv2.rectangle(img_copy, (x1, y1), (x1 + w1, y1 +(h1-contour_height[1])), (0, 255, 0), 2)
        #             #print("Full")
        #             cv2.putText(imgcopy, "Full", (x1 + 10, contour_height - 20), cv2.FONT_HERSHEY_PLAIN, 1, (0, 255, 0), 2)
        #             #cv2.imshow("Decision", imgcopy)
        #         else:
        #             #cv2.rectangle(img_copy, (x1, y1), (x1 + w1, y1 + (y1-contour_height[1])), (0, 0, 255), 2)
        #             #print("Need Refill")
        #             cv2.putText(imgcopy, "Low", (x1 + 10, contour_height - 20), cv2.FONT_HERSHEY_PLAIN, 1, (0, 0, 255), 2)
        #             #cv2.imshow("Decision", imgcopy) 
    return (imgcopy)
    #await asyncio.sleep(1)
    

async def run1():
    cv2.namedWindow("detection", cv2.WINDOW_AUTOSIZE)
    while True:
        img_resp=urllib.request.urlopen(url)
        imgnp=np.array(bytearray(img_resp.read()),dtype=np.uint8)
        img = cv2.imdecode(imgnp,-1)
        imgcopy = img.copy()
        bbox, label, conf = cv.detect_common_objects(img)
        img = draw_bbox(img, bbox, label, conf)
        result = imgcopy.copy()

        for x in range(len(label)):
            if label[x] == 'cup' or label[x] == 'bottle' or label[x] == 'glass':
                result = await waterLevel(imgcopy,bbox[x])

        

        
        #cv2.imshow('detection',img)
        cv2.imshow('result',result)
        key=cv2.waitKey(5)
        if key==ord('q'):
            break
            
    cv2.destroyAllWindows()
 
if __name__ == '__main__':
    print("started")

    loop = asyncio.get_event_loop()
    loop.run_until_complete(run1())

    """
    with concurrent.futures.ProcessPoolExecutor() as executer:
            f1= executer.submit(run1)
            #f2= executer.submit(run2)
    """